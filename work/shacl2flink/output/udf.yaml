---
apiVersion: industry-fusion.com/v1alpha1
kind: flinkpythonudf
metadata:
  name: hash
spec:
  filename: hash
  version: v1
  class: "from pyflink.table import DataTypes\nfrom pyflink.table.udf import ScalarFunction,\
    \ udf\n\n\nclass HashCode(ScalarFunction):\n    def __init__(self):\n        self.factor\
    \ = 12\n\n    def eval(self, s):\n        return hash(s) * self.factor\n\n\ndef\
    \ register(table_env):\n    hashcode = udf(HashCode(), result_type=DataTypes.BIGINT())\n\
    \    table_env.create_temporary_function(\"hash\", hashcode)\n"
---
apiVersion: industry-fusion.com/v1alpha1
kind: flinkpythonudf
metadata:
  name: statetime
spec:
  filename: statetime
  version: v1
  class: "from pyflink.common import Row\nfrom pyflink.table import AggregateFunction,\
    \ DataTypes\nfrom pyflink.table.udf import udaf\nfrom enum import IntEnum\n\n\n\
    class Index(IntEnum):\n    \"\"\"SQL Job states as defined by Flink\"\"\"\n  \
    \  STATETIME = 0\n    LAST_STATE = 1\n    LAST_TIME = 2\n    FIRST_STATE = 3\n\
    \    FIRST_TIME = 4\n    BUFFER_ACCUM = 5\n    BUFFER_RETRACT = 6\n\n\nclass Statetime(AggregateFunction):\n\
    \n    def create_accumulator(self):\n        # statetime, last_state, last_timeInMs,\
    \ first_state, first_timeInMs\n        return Row(None, None, None, None, None,\
    \ {}, {})\n\n    def get_value(self, accumulator):\n        self.calc_buffer(accumulator)\n\
    \        return accumulator[Index.STATETIME]\n\n    def accumulate(self, accumulator,\
    \ state, timeInMs):\n        if state is None or timeInMs is None:\n         \
    \   return\n        if timeInMs in accumulator[Index.BUFFER_RETRACT]:\n      \
    \      del accumulator[Index.BUFFER_RETRACT][timeInMs]\n        else:\n      \
    \      accumulator[Index.BUFFER_ACCUM][timeInMs] = state\n\n    def retract(self,\
    \ accumulator, state, timeInMs):\n        if state is None or timeInMs is None:\n\
    \            return\n        if timeInMs in accumulator[Index.BUFFER_ACCUM]:\n\
    \            del accumulator[Index.BUFFER_ACCUM][timeInMs]\n        else:\n  \
    \          accumulator[Index.BUFFER_RETRACT][timeInMs] = state\n\n    def get_result_type(self):\n\
    \        return DataTypes.BIGINT()\n\n    def get_accumulator_type(self):\n  \
    \      return DataTypes.ROW([\n                             DataTypes.FIELD(\"\
    f0\", DataTypes.INT()),\n                             DataTypes.FIELD(\"f1\",\
    \ DataTypes.BIGINT())])\n\n    def calc_buffer(self, accumulator):\n        abuffer\
    \ = accumulator[Index.BUFFER_ACCUM]\n        rbuffer = accumulator[Index.BUFFER_RETRACT]\n\
    \n        if abuffer:\n            if accumulator[Index.LAST_STATE] is None or\
    \ accumulator[Index.LAST_TIME] is None or \\\n                    accumulator[Index.FIRST_STATE]\
    \ is None or accumulator[Index.FIRST_TIME] is None:\n                ts = min(abuffer)\n\
    \                accumulator[Index.LAST_STATE] = abuffer[ts]\n               \
    \ accumulator[Index.LAST_TIME] = ts\n                accumulator[Index.FIRST_STATE]\
    \ = abuffer[ts]\n                accumulator[Index.FIRST_TIME] = ts\n        \
    \    sorted_high = filter(lambda x: x > accumulator[Index.LAST_TIME], sorted(abuffer))\n\
    \            sorted_low = filter(lambda x: x < accumulator[Index.FIRST_TIME],\
    \ sorted(abuffer, reverse=True))\n            for ts in list(sorted_low) + list(sorted_high):\n\
    \                if ts > accumulator[Index.LAST_TIME]:\n                    if\
    \ accumulator[Index.STATETIME] is None and accumulator[Index.LAST_STATE] == 1:\n\
    \                        accumulator[Index.STATETIME] = ts - accumulator[Index.LAST_TIME]\n\
    \                    elif accumulator[Index.LAST_STATE] == 1:\n              \
    \          accumulator[Index.STATETIME] += ts - accumulator[Index.LAST_TIME]\n\
    \                    accumulator[Index.LAST_STATE] = abuffer[ts]\n           \
    \         accumulator[Index.LAST_TIME] = ts\n                elif ts < accumulator[Index.FIRST_TIME]:\n\
    \                    if accumulator[Index.STATETIME] is None and abuffer[ts] ==\
    \ 1:\n                        accumulator[Index.STATETIME] = accumulator[Index.FIRST_TIME]\
    \ - ts\n                    elif abuffer[ts] == 1:\n                        accumulator[Index.STATETIME]\
    \ += accumulator[Index.FIRST_TIME] - ts\n                    accumulator[Index.FIRST_STATE]\
    \ = abuffer[ts]\n                    accumulator[Index.FIRST_TIME] = ts\n\n  \
    \      if accumulator[Index.LAST_STATE] is not None and accumulator[Index.LAST_TIME]\
    \ is not None \\\n            and accumulator[Index.FIRST_STATE] is not None and\
    \ accumulator[Index.FIRST_TIME] is not None \\\n                and rbuffer:\n\
    \            sorted_buffer = sorted(rbuffer)\n            while sorted_buffer:\n\
    \                min_ts = sorted_buffer[0]\n                max_ts = sorted_buffer[-1]\n\
    \                if min_ts < accumulator[Index.FIRST_TIME]:\n                \
    \    sorted_buffer.pop(0)\n                    continue\n                if max_ts\
    \ > accumulator[Index.LAST_TIME]:\n                    sorted_buffer.pop()\n \
    \                   continue\n                if accumulator[Index.LAST_TIME]\
    \ - max_ts > min_ts - accumulator[Index.FIRST_TIME]:\n                    # assuming\
    \ retracting from FIRST_TIME up\n                    # Heuristic: It is closer\
    \ to FIRST_TIME\n                    if accumulator[Index.FIRST_STATE] == 1:\n\
    \                        accumulator[Index.STATETIME] -= min_ts - accumulator[Index.FIRST_TIME]\n\
    \                    accumulator[Index.FIRST_STATE] = rbuffer[min_ts]\n      \
    \              accumulator[Index.FIRST_TIME] = min_ts\n                    sorted_buffer.pop(0)\n\
    \                else:\n                    # retract from LAST_TIME\n       \
    \             if rbuffer[max_ts] == 1:\n                        accumulator[Index.STATETIME]\
    \ -= accumulator[Index.LAST_TIME] - max_ts\n                    accumulator[Index.LAST_STATE]\
    \ = rbuffer[max_ts]\n                    accumulator[Index.LAST_TIME] = max_ts\n\
    \                    sorted_buffer.pop()\n\n        accumulator[Index.BUFFER_ACCUM]\
    \ = {}\n        accumulator[Index.BUFFER_RETRACT] = {}\n\n\ndef register(table_env):\n\
    \    statetime = udaf(Statetime())\n    table_env.create_temporary_function(\"\
    statetime\", statetime)\n"
